import pandas as pd
import matplotlib.pyplot as plt

# -------------------
# Load data
# -------------------
df = pd.read_csv("your_file.csv")

# -------------------
# Identify columns
# -------------------
meta_cols = df.columns[:8].tolist()          # first 8 metadata columns
price_cols = df.columns[8:].tolist()         # from Unnamed:8 onwards (prices)

# -------------------
# Normalize to returns relative to t0 (add date price)
# -------------------
df_perf = df.copy()
P0 = df[price_cols[0]]   # price at add date (t0)

for c in price_cols:
    df_perf[c] = (df[c] / P0) - 1

# -------------------
# Fixed horizon analysis (approx 21 trading days per month)
# -------------------
months_map = {
    "1m": 21,
    "2m": 42,
    "3m": 63,
    "4m": 84,
    "5m": 105,
    "6m": 126
}

results = []

for label, day in months_map.items():
    # price_cols[0] is t0, so day offset = price_cols[day]
    if day < len(price_cols):  
        col_name = price_cols[day]  
        tmp = df_perf[[meta_cols[1], col_name]].copy()  # ticker + return
        tmp.rename(columns={col_name: "return"}, inplace=True)
        tmp["horizon"] = label
        results.append(tmp)

perf_long = pd.concat(results)

# Mean return per horizon
mean_perf = perf_long.groupby("horizon")["return"].mean()

# -------------------
# Full average performance curve
# -------------------
avg_curve = df_perf[price_cols].mean(axis=0)

# -------------------
# Plotting
# -------------------

# 1. Snapshot mean returns bar chart
plt.figure(figsize=(8,5))
mean_perf.plot(kind="bar")
plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Average Return")
plt.title("Average Return at Fixed Horizons")
plt.show()

# 2. Distribution boxplots
plt.figure(figsize=(8,5))
perf_long.boxplot(by="horizon", column="return", grid=False)
plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Return")
plt.title("Return Distribution by Horizon")
plt.suptitle("")  # remove default pandas title
plt.show()

# 3. Full performance curve (average cumulative return path)
plt.figure(figsize=(10,6))
avg_curve.plot()
plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Average Return")
plt.xlabel("Days Since Add Date (t0)")
plt.title("Average Performance Curve Across All Names")
plt.show()


import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# -------------------
# Load data
# -------------------
df = pd.read_csv("your_file.csv")

# -------------------
# Identify columns
# -------------------
bbg_col = df.columns[6]   # bbg_ticker
date_col = df.columns[7]  # add_date
price_cols = df.columns[8:].tolist()

# -------------------
# Normalize prices into returns
# -------------------
df_perf = df.copy()
P0 = df[price_cols[0]]  # price at t0 (add date)

for c in price_cols:
    df_perf[c] = (df[c] / P0) - 1

# -------------------
# Horizon mapping (approx 21 trading days ~ 1 month)
# -------------------
months_map = {
    "1m": 21,
    "2m": 42,
    "3m": 63,
    "4m": 84,
    "5m": 105,
    "6m": 126
}

results = []

for label, day in months_map.items():
    if day < len(price_cols):  # only if horizon exists
        col_name = price_cols[day]
        tmp = df_perf[[bbg_col, date_col, col_name]].copy()
        tmp.rename(columns={col_name: "return"}, inplace=True)
        tmp["horizon"] = label
        results.append(tmp)

perf_long = pd.concat(results)

# -------------------
# Average performance curve
# -------------------
avg_curve = df_perf[price_cols].mean(axis=0)
day_nums = list(range(len(price_cols)))  # 0,1,2,...
avg_curve.index = day_nums

plt.figure(figsize=(10,6))
avg_curve.plot()
plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Average Return")
plt.xlabel("Days Since Add Date (t0)")
plt.title("Average Performance Curve Across All Names")
plt.show()

# -------------------
# Boxplot with labeled outliers
# -------------------
plt.figure(figsize=(10,6))
sns.boxplot(x="horizon", y="return", data=perf_long, showfliers=True)
sns.stripplot(x="horizon", y="return", data=perf_long, color="black", size=3, alpha=0.5)

# Label outliers (top & bottom 3 per horizon)
for horizon in perf_long["horizon"].unique():
    sub = perf_long[perf_long["horizon"] == horizon]
    top = sub.nlargest(3, "return")
    bottom = sub.nsmallest(3, "return")
    extremes = pd.concat([top, bottom])
    x_pos = list(perf_long["horizon"].unique()).tolist().index(horizon)
    for _, row in extremes.iterrows():
        plt.text(
            x=x_pos,
            y=row["return"],
            s=row[bbg_col],
            fontsize=8,
            ha="center",
            va="bottom" if row["return"] > 0 else "top"
        )

plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Return")
plt.title("Return Distribution by Horizon (with Outliers Labeled)")
plt.show()

# -------------------
# Stacked plot of all tickers' curves
# -------------------
plt.figure(figsize=(12,7))

for _, row in df_perf.iterrows():
    returns = row[price_cols].values
    returns = (returns / returns[0]) - 1  # normalize
    plt.plot(day_nums, returns, alpha=0.3, linewidth=1, color="gray")

# Overlay average curve
plt.plot(day_nums, avg_curve, color="red", linewidth=2, label="Average")

plt.axhline(0, color="black", linestyle="--", linewidth=1)
plt.ylabel("Return")
plt.xlabel("Days Since Add Date (t0)")
plt.title("All Tickers Performance Curves (Stacked)")
plt.legend()
plt.show()

Fund,Ticker/ISIN,Underlying Index,AuM
Xtrackers MSCI World UCITS ETF 1C,IE00BJ0KDQ92,MSCI World,€20.63B
Xtrackers S&P 500 UCITS ETF 4C,IE000Z9SJA06,S&P 500,€1.53B
Xtrackers Artificial Intelligence & Big Data UCITS ETF 1C,IE00BGV5VN51,Nasdaq Global AI & Big Data Index,€5.50B
Xtrackers II EUR Overnight Rate Swap UCITS ETF 1C,LU0290358497,EUR Overnight Rate Swap Index,€18.37M
Xtrackers DAX UCITS ETF 1C Core Direct,XDAX,DAX,€6.48B
Xtrackers Euro Stoxx 50 UCITS ETF 1D Core,LU0274211217,EURO STOXX 50,€9.94B
Xtrackers Artificial Intelligence & Big Data ETF (US),XAIX,Nasdaq Global AI & Big Data Index,Part of $21B suite
Xtrackers USD High Yield BB-B ex Financials ETF,HYLB,ICE BofA BB-B Non-Financials HY Index,$3.53B
Xtrackers US National Critical Technologies ETF,CRTC,Solactive Whitney US Critical Technologies Index,N/A
Xtrackers USA Net Zero Pathway Paris Aligned UCITS ETF 1C ESG,N/A,Solactive-ISS ESG USA Net Zero Pathway Index,N/A
Xtrackers Europe Net Zero Pathway Paris Aligned UCITS ETF 1C ESG,N/A,Solactive-ISS ESG Europe Net Zero Pathway Index,N/A
Xtrackers Japan Net Zero Pathway Paris Aligned UCITS ETF 1C ESG,N/A,Solactive-ISS ESG Japan Net Zero Pathway Index,N/A
Xtrackers Emerging Markets Net Zero Pathway Paris Aligned UCITS ETF 1C ESG,N/A,Solactive-ISS ESG EM Net Zero Pathway Index,N/A
Xtrackers MSCI China A ESG Screened Swap UCITS ETF 1C,LU2469465822,MSCI China A Inclusion Select ESG Screened Index,€5.13M
Xtrackers CSI300 Swap UCITS ETF 1C,LU0779800910,CSI 300 Swap Index,€2.05B
Xtrackers Nikkei 225 UCITS ETF 1D,XDJP,Nikkei 225,€1.60B
Xtrackers MSCI China UCITS ETF 1C,N/A,MSCI China,€1.88B


import pandas as pd
import matplotlib.pyplot as plt

# === Load your CSV ===
df = pd.read_csv("your_file.csv")

# Expected columns: ['side', 'quantity', 'bbg_ticker', 'add_date', price columns...]
price_cols = df.columns[4:]  # first 4 cols are meta, rest are Unnamed:8, Unnamed:9, ...

# Compute returns relative to trade date
returns = (df[price_cols].T / df[price_cols].iloc[:,0].values).T - 1
returns["bbg_ticker"] = df["bbg_ticker"]
returns["add_date"] = pd.to_datetime(df["add_date"])
returns["side"] = df["side"].str.lower()
returns["quantity"] = df["quantity"]

# Map side → +1 (long), -1 (short)
returns["weight"] = returns["quantity"] * returns["side"].map({"long": 1, "short": -1})

# === Group by trade date ===
portfolio_curves = {}

for trade_date, group in returns.groupby("add_date"):
    # Weighted average across tickers traded that day
    weighted = (group[price_cols].T * group["weight"].values).T
    portfolio_curve = weighted.sum(axis=0) / group["quantity"].sum()
    portfolio_curves[trade_date] = portfolio_curve

# Convert to DataFrame
portfolio_df = pd.DataFrame(portfolio_curves)

# Average performance across all trade dates
average_curve = portfolio_df.mean(axis=1)

# === Relabel X-axis as months (1m, 2m, …) ===
days = range(len(price_cols))
months = [f"{i}m" for i in range(1,7)]
month_positions = [21*i for i in range(1,7)]  # ~21 trading days = 1m

# === Plot portfolio curves ===
plt.figure(figsize=(12,7))

# Plot each trade date curve
for trade_date in portfolio_df.columns:
    plt.plot(days, portfolio_df[trade_date].values, alpha=0.4, label=str(trade_date.date()))

# Plot average curve
plt.plot(days, average_curve.values, color="black", linewidth=2, label="Average")

plt.axhline(0, color="black", linewidth=0.8)
plt.xticks(month_positions, months)
plt.xlabel("Time since trade date")
plt.ylabel("Performance vs. trade date (%)")
plt.title("Portfolio Performance by Trade Date")
plt.legend(loc="best", fontsize=8)
plt.grid(True)
plt.show()
