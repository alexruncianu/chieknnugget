import pandas as pd, numpy as np

# ---------- Bloomberg backend ----------
BACKEND = None
try:
    from xbbg import blp as _blp
    BACKEND = "xbbg"
except Exception:
    try:
        import pdblp
        _con = pdblp.BCon(debug=False, port=8194, timeout=10000)
        _con.start()
        BACKEND = "pdblp"
    except Exception as e:
        raise RuntimeError("No Bloomberg backend found") from e


# ---------- Bloomberg wrappers ----------
def bds(tkr, field):
    if BACKEND == "xbbg":
        return _blp.bds(tkr, field)
    else:
        return _con.bds(tkr, field)

def bdp(tkrs, field):
    if BACKEND == "xbbg":
        return _blp.bdp(tkrs, field)
    else:
        df = _con.bdp(tkrs, field)
        return df.set_index("ticker")

def bdh(tkrs, field, start, end, **kwargs):
    if BACKEND == "xbbg":
        return _blp.bdh(tkrs, field, start_date=start, end_date=end, **kwargs)
    else:
        df = _con.bdh(tkrs, field, start, end, **kwargs)
        return df.pivot(index="date", columns="ticker", values=field)

def bdib_one(tkr, start_dt, end_dt, interval=1):
    if BACKEND == "xbbg":
        return _blp.bdib(ticker=tkr, dt=start_dt, end_dt=end_dt, interval=interval)
    else:
        try:
            df = _con.get_intraday_bar(
                tkr, start_dt, end_dt, eventType="TRADE", interval=interval
            )
            df = df.rename(columns={"close": "price"}).set_index("time")
            return df
        except Exception:
            return pd.DataFrame()


# ---------- Members + Weights ----------
def _members_and_weights(idx_ticker):
    df = bds(idx_ticker, "INDX_MEMBERS")
    df.columns = [c.lower().replace(" ", "_") for c in df.columns]

    # find ticker column
    for c in df.columns:
        if "ticker" in c:
            tcol = c
            break
    else:
        raise KeyError("No ticker column found")

    # find weight column
    wcol = None
    for c in df.columns:
        if "weight" in c:
            wcol = c
            break

    tickers = df[tcol].tolist()
    weights = df[wcol].astype(float).tolist() if wcol else [None] * len(tickers)
    return tickers, weights


# ---------- Run a test ----------
if __name__ == "__main__":
    print("Testing Bloomberg connection...")
    try:
        tickers, weights = _members_and_weights("SPX Index")
        print("First 5 tickers:", tickers[:5])
        print("First 5 weights:", weights[:5])
    except Exception as e:
        print("Error:", e)


import bqdata as bqd
import pandas as pd

# Assume you already have a DataFrame like:
# movers_df = pd.DataFrame({
#     "date": [...],         # event date (after-hours mover date)
#     "ticker": [...],       # e.g. "AAPL US Equity"
#     "move": [...]          # after-hours % move
# })
# index = event date if you prefer

movers_df["date"] = pd.to_datetime(movers_df["date"])

# Step 1: get next trading day returns for each (ticker, date)
def get_next_day_return(ticker, date):
    # pull close prices around event date
    px = bqd.get_series(ticker, "PX_LAST", date, date + pd.Timedelta(days=5), period="DAILY")
    df = pd.DataFrame(px, columns=["close"])
    df.index = pd.to_datetime(df.index).sort_values()

    if date not in df.index:
        return None
    
    try:
        today_close = df.loc[date, "close"]
        next_date = df.index[df.index.get_loc(date) + 1]
        next_close = df.loc[next_date, "close"]
        return (next_close / today_close) - 1
    except:
        return None

movers_df["next_day_return"] = movers_df.apply(
    lambda row: get_next_day_return(row["ticker"], row["date"]),
    axis=1
)

# Step 2: analyze performance
summary = movers_df.groupby(pd.qcut(movers_df["move"], 5))["next_day_return"].mean()
print("Average next-day return by after-hours move quintile:")
print(summary)

# Step 3: overall stats
print("Overall average next-day return:", movers_df["next_day_return"].mean())
