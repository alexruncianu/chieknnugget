import bql
import pandas as pd
import numpy as np

bq = bql.Service()

# Example basket (replace with your basket ticker)
basket = "MY_BASKET Index"

# 1. Pull 1y of daily prices
req = bql.Request(
    basket,
    {
        "px": bq.data.px_last(dates=bq.func.range("-1Y", None), freq="D")
    }
)

res = bq.execute(req)
df = res[0].df()

# 2. Calculate daily returns
df["return"] = df["px"].pct_change()

# 3. Standard deviation of returns (volatility)
vol = df["return"].std()

print(f"1Y Basket Return Std Dev: {vol:.2%}")

----

import bql
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import ipywidgets as widgets

# --------------------------
# 1. BQL Setup
# --------------------------
bq = bql.Service()

# Define baskets (replace with your Bloomberg baskets or indices)
baskets = {
    "Long Momentum": "LONG_MOMO Index",
    "Short Momentum": "SHORT_MOMO Index",
    "Long-Short Momentum": "LONGSHORT_MOMO Index"
}

# --------------------------
# 2. Helper Functions
# --------------------------

def get_sector_breakdown(basket, name):
    """Fetch sector weights for a basket."""
    req = bql.Request(
        basket,
        {
            "sector": bq.data.gics_sector(),
            "weight": bq.data.weight()
        }
    )
    df = bq.execute(req)[0].df()
    df["Basket"] = name
    return df

def get_basket_returns(basket, name):
    """Fetch daily price history & compute returns."""
    req = bql.Request(
        basket,
        {"px": bq.data.px_last(dates=bq.func.range("-1Y", None), freq="D")}
    )
    res = bq.execute(req)
    df = res[0].df().rename(columns={"px": "price"})
    df["return"] = df["price"].pct_change()
    df["Basket"] = name
    return df.dropna()

def compute_risk_stats(df):
    """Compute volatility, Sharpe ratio, drawdown."""
    stats = {}
    rets = df["return"].dropna()
    if len(rets) == 0:
        return {"Volatility": np.nan, "Sharpe": np.nan, "MaxDD": np.nan}

    vol = rets.std() * np.sqrt(252)
    sharpe = rets.mean() / rets.std() * np.sqrt(252)
    cum = (1 + rets).cumprod()
    roll_max = cum.cummax()
    drawdown = (cum - roll_max) / roll_max
    maxdd = drawdown.min()

    stats["Volatility"] = vol
    stats["Sharpe"] = sharpe
    stats["MaxDD"] = maxdd
    return stats

# --------------------------
# 3. Fetch Data
# --------------------------
sector_df = pd.concat([get_sector_breakdown(b, n) for n, b in baskets.items()])
returns_df = pd.concat([get_basket_returns(b, n) for n, b in baskets.items()])

risk_stats = pd.DataFrame([
    {"Basket": n, **compute_risk_stats(returns_df[returns_df["Basket"]==n])}
    for n in baskets.keys()
])

# --------------------------
# 4. Visualisations
# --------------------------

# Sector Breakdown (Grouped Bar)
fig_sector = px.bar(
    sector_df,
    x="sector",
    y="weight",
    color="Basket",
    barmode="group",
    title="Sector Breakdown Across Baskets"
)

# Treemap Example
fig_tree = px.treemap(
    sector_df,
    path=["Basket", "sector"],
    values="weight",
    color="weight",
    color_continuous_scale="Blues",
    title="Treemap of Sector Weights"
)

# Performance Time Series
cum_returns = (
    returns_df.groupby(["Basket","date"])["return"]
    .mean()
    .groupby(level=0).cumsum()
    .reset_index()
)
cum_returns["cum_return"] = (1 + returns_df["return"]).groupby(returns_df["Basket"]).cumprod().values

fig_perf = px.line(
    cum_returns,
    x="date",
    y="cum_return",
    color="Basket",
    title="Cumulative Returns (1Y)"
)

# Correlation Heatmap
pivot = returns_df.pivot(index="date", columns="Basket", values="return").dropna()
corr = pivot.corr()

fig_corr = go.Figure(
    data=go.Heatmap(
        z=corr.values,
        x=corr.columns,
        y=corr.index,
        colorscale="RdYlGn",
        zmin=-1, zmax=1
    )
)
fig_corr.update_layout(title="Correlation Heatmap Between Baskets")

# Risk Stats Table
fig_table = go.Figure(
    data=[go.Table(
        header=dict(values=list(risk_stats.columns), fill_color="lightgrey", align="center"),
        cells=dict(values=[risk_stats[c] for c in risk_stats.columns], align="center")
    )]
)
fig_table.update_layout(title="Risk Statistics (1Y)")

# --------------------------
# 5. Display in App Layout
# --------------------------
app = widgets.VBox([
    widgets.HTML("<h2>Basket Dashboard</h2>"),
    widgets.HTML("<b>Sector Breakdown</b>"),
    widgets.Output(),
    widgets.HTML("<b>Treemap</b>"),
    widgets.Output(),
    widgets.HTML("<b>Cumulative Performance</b>"),
    widgets.Output(),
    widgets.HTML("<b>Correlation Heatmap</b>"),
    widgets.Output(),
    widgets.HTML("<b>Risk Stats Table</b>"),
    widgets.Output(),
])

# Render plots into widget outputs
outs = app.children
for fig, out in zip([fig_sector, fig_tree, fig_perf, fig_corr, fig_table], outs[2::2]):
    with out:
        fig.show()

app

import ipywidgets as widgets
from IPython.display import display, clear_output
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import bql

# Connect to BQL
bq = bql.Service()

# =====================
# Function to Get Sector Returns
# =====================
def get_sector_returns(basket_id, start_date, end_date):
    """
    Query BQL for basket returns, sector classification, and weights.
    Then compute weighted sector returns.
    """

    # 1. Basket returns
    basket = bql.Function(basket_id)
    returns_field = bql.Fields.PX_PERCENT_CHANGE("daily")
    dates = bql.DateRange(start_date, end_date, freq="D")
    req = bql.Request(basket, returns_field, dates=dates)
    res = bq.execute(req)
    df_returns = res[0].df().rename(columns={"PX_PERCENT_CHANGE": "Return"}).reset_index()

    # 2. Sector classification
    req_sector = bql.Request(basket, bql.Fields.GICS_SECTOR_NAME())
    df_sector = bq.execute(req_sector)[0].df().reset_index()

    # 3. Weights
    req_wt = bql.Request(basket, bql.Fields.INDEX_WEIGHT())
    df_wt = bq.execute(req_wt)[0].df().reset_index()

    # Merge everything
    df_all = (
        df_returns
        .merge(df_sector, on="ID")
        .merge(df_wt, on="ID")
    )

    # Compute sector-level weighted returns
    sector_group = df_all.groupby(["date", "GICS_SECTOR_NAME"])
    sector_returns = (
        sector_group.apply(lambda x: (x["Return"] * x["INDEX_WEIGHT"]).sum())
        .reset_index()
        .rename(columns={0: "SectorReturn"})
    )

    return sector_returns

# =====================
# Widgets
# =====================
basket_dropdown = widgets.Dropdown(
    options=["SPX Index", "NDX Index", "RTY Index", "SX5E Index"],
    value="SPX Index",
    description="Basket:",
    style={"description_width": "initial"}
)

start_picker = widgets.DatePicker(
    description="Start:",
    value=pd.to_datetime("2025-01-01"),
    style={"description_width": "initial"}
)

end_picker = widgets.DatePicker(
    description="End:",
    value=pd.to_datetime("2025-02-02"),
    style={"description_width": "initial"}
)

run_button = widgets.Button(
    description="Run Sector Breakdown",
    button_style="success",
    layout=widgets.Layout(width="50%")
)

output = widgets.Output()

# =====================
# Callback
# =====================
def run_analysis(_):
    with output:
        clear_output(wait=True)
        try:
            basket = basket_dropdown.value
            start = start_picker.value.strftime("%Y-%m-%d")
            end = end_picker.value.strftime("%Y-%m-%d")

            df_sector = get_sector_returns(basket, start, end)

            if df_sector.empty:
                print("‚ö†Ô∏è No data returned. Check inputs.")
                return

            # ---- Table
            print(f"üìä Sector Breakdown for {basket} ({start} ‚Üí {end})")
            display(df_sector.head(20))

            # ---- Heatmap
            pivot_df = df_sector.pivot(index="date", columns="GICS_SECTOR_NAME", values="SectorReturn")

            plt.figure(figsize=(12,6))
            sns.heatmap(pivot_df.T, cmap="RdYlGn", center=0, cbar_kws={'label': 'Return'})
            plt.title(f"Sector Returns Heatmap: {basket}", fontsize=14)
            plt.xlabel("Date")
            plt.ylabel("Sector")
            plt.tight_layout()
            plt.show()

        except Exception as e:
            print("‚ùå Error:", str(e))

run_button.on_click(run_analysis)

# =====================
# Display Layout
# =====================
ui = widgets.VBox([
    widgets.HTML("<h2 style='color:navy'>üìà Sector Return Dashboard</h2>"),
    widgets.HBox([basket_dropdown, start_picker, end_picker]),
    run_button,
    output
])

display(ui)

import ipywidgets as widgets
from IPython.display import display, clear_output
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# -------------------------------
# Example Functions (Replace with your BQL queries)
# -------------------------------

def xyz(baskets, start_date, end_date):
    """
    Example: Sector returns for a basket between dates
    Replace the mock df with your real BQL query.
    """
    dates = pd.date_range(start_date, end_date, freq="D")
    sectors = ["Tech", "Financials", "Energy", "Healthcare"]

    data = {s: np.random.randn(len(dates)) / 100 for s in sectors}
    df = pd.DataFrame(data, index=dates)

    return df


def std_moves(baskets, start_date, end_date):
    """
    Example: Std dev moves for baskets
    Replace the mock df with your real BQL query.
    """
    data = {
        "Basket": baskets,
        "StdDev": np.random.rand(len(baskets)) * 2
    }
    df = pd.DataFrame(data)
    return df

# -------------------------------
# Widgets
# -------------------------------

basket_dropdown = widgets.SelectMultiple(
    options=["SPX Index", "NDX Index", "RTY Index", "SX5E Index"],
    value=["SPX Index"],
    description="Baskets",
    style={"description_width": "initial"}
)

start_picker = widgets.DatePicker(
    description="Start"
)

end_picker = widgets.DatePicker(
    description="End"
)

chart_type = widgets.Dropdown(
    options=["Bar Chart (Last Day)", "Line Chart (Cumulative Returns)"],
    value="Bar Chart (Last Day)",
    description="Chart Type"
)

run_button = widgets.Button(
    description="Run Analysis",
    button_style="success"
)

output = widgets.Output()

# -------------------------------
# Callback
# -------------------------------

def run_analysis(_):
    with output:
        clear_output(wait=True)
        baskets = list(basket_dropdown.value)
        if not baskets or not start_picker.value or not end_picker.value:
            print("Please select baskets and valid start/end dates.")
            return

        start = start_picker.value.strftime("%Y-%m-%d")
        end = end_picker.value.strftime("%Y-%m-%d")

        # Call the functions (now returning DataFrames)
        df_sector = xyz(baskets, start, end)
        df_std = std_moves(baskets, start, end)

        # Tabs for display
        tab = widgets.Tab()
        tab.children = [
            widgets.Output(),  # Sector Returns
            widgets.Output(),  # Std Dev Moves
            widgets.Output()   # Charts
        ]
        tab.set_title(0, "Sector Returns")
        tab.set_title(1, "Std Dev Moves")
        tab.set_title(2, "Charts")

        # Fill tabs
        with tab.children[0]:
            display(df_sector)

        with tab.children[1]:
            display(df_std)

        with tab.children[2]:
            if chart_type.value == "Bar Chart (Last Day)":
                try:
                    df_sector.iloc[-1].plot(
                        kind="bar", figsize=(7,4),
                        color="steelblue", edgecolor="black"
                    )
                    plt.title(f"Sector Returns on {df_sector.index[-1].date()}")
                    plt.ylabel("Return")
                    plt.show()
                except:
                    print("No data available for bar chart")
            else:
                try:
                    (1 + df_sector).cumprod().plot(figsize=(8,4))
                    plt.title("Cumulative Sector Returns")
                    plt.ylabel("Growth of 1 unit")
                    plt.show()
                except:
                    print("No data available for line chart")

        display(tab)

run_button.on_click(run_analysis)

# -------------------------------
# Display Layout
# -------------------------------

ui = widgets.VBox([
    widgets.HTML("<h2 style='color:navy'>Basket Return & Risk Dashboard</h2>"),
    widgets.HBox([basket_dropdown, start_picker, end_picker]),
    chart_type,
    run_button,
    output
])

display(ui)

import bql
import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output
import matplotlib.pyplot as plt

# Connect to BQL
bq = bql.Service()

# ----------------------------------------------------
# Example Function (replace this with your real query)
# ----------------------------------------------------
def get_sector_returns(basket, start_date, end_date):
    # Example: this would normally be a BQL query
    dates = pd.date_range(start_date, end_date, freq="D")
    df = pd.DataFrame(
        np.random.randn(len(dates), 4) / 100,
        index=dates,
        columns=["Tech", "Financials", "Energy", "Healthcare"]
    )
    return df

# ----------------------------------------------------
# Widgets
# ----------------------------------------------------
basket_dropdown = widgets.Dropdown(
    options=["SPX Index", "NDX Index", "RTY Index", "SX5E Index"],
    value="SPX Index",
    description="Basket:",
    layout=widgets.Layout(width="250px")
)

start_picker = widgets.DatePicker(
    description="Start Date:",
    layout=widgets.Layout(width="200px")
)

end_picker = widgets.DatePicker(
    description="End Date:",
    layout=widgets.Layout(width="200px")
)

run_button = widgets.Button(
    description="Run Analysis",
    button_style="info",
    layout=widgets.Layout(width="180px")
)

output = widgets.Output()

# ----------------------------------------------------
# Callback
# ----------------------------------------------------
def run_analysis(_):
    with output:
        clear_output(wait=True)
        
        # Check inputs
        if not basket_dropdown.value or not start_picker.value or not end_picker.value:
            print("Please select a basket and dates.")
            return
        
        basket = basket_dropdown.value
        start = start_picker.value.strftime("%Y-%m-%d")
        end = end_picker.value.strftime("%Y-%m-%d")
        
        # Get DataFrame from function
        df = get_sector_returns(basket, start, end)
        
        # Display DataFrame
        print(f"Sector returns for {basket} ({start} ‚Üí {end}):")
        display(df.style.background_gradient(cmap="coolwarm"))
        
        # Plot chart
        df.cumsum().plot(figsize=(10, 5), linewidth=2)
        plt.title(f"Cumulative Sector Returns: {basket}", fontsize=14)
        plt.ylabel("Cumulative Return")
        plt.grid(True, alpha=0.3)
        plt.show()

run_button.on_click(run_analysis)

# ----------------------------------------------------
# Layout
# ----------------------------------------------------
controls = widgets.HBox([basket_dropdown, start_picker, end_picker, run_button])
ui = widgets.VBox([controls, output])

display(ui)

