
# TKMS Buy-at-Close, Sell-Next-Day Strategy

import pandas as pd
import matplotlib.pyplot as plt

# 1. Load and prepare data
file_path = "TKMS_intraday.csv"
df = pd.read_csv(file_path)

# Parse timestamps
df['Date_Time'] = pd.to_datetime(df['Date_Time'], format='%d/%m/%Y %H:%M')

# Sort chronologically
df = df.sort_values('Date_Time').reset_index(drop=True)

# Add date column
df['Date'] = df['Date_Time'].dt.date

# 2. Identify daily closes and opens
daily_close = df.groupby('Date').tail(1)[['Date_Time', 'Price']].rename(columns={'Price': 'Close_Price'})
daily_open = df.groupby('Date').head(1)[['Date_Time', 'Price']].rename(columns={'Price': 'Open_Price'})

# Merge to get close and next open prices
daily = pd.merge(daily_close, daily_open, on='Date', suffixes=('_Close', '_Open'))
daily = daily[['Date', 'Close_Price', 'Open_Price']]

# 3. Compute Buy-Close → Sell-Next-Day return
returns = []
dates = sorted(daily['Date'])

for i in range(len(dates) - 1):
    date_close = dates[i]
    date_next_open = dates[i + 1]

    close_price = daily.loc[daily['Date'] == date_close, 'Close_Price'].values[0]
    next_open_price = daily.loc[daily['Date'] == date_next_open, 'Open_Price'].values[0]

    ret = (next_open_price - close_price) / close_price
    returns.append({
        'Buy_Date': date_close,
        'Sell_Date': date_next_open,
        'Buy_Close': close_price,
        'Sell_Open': next_open_price,
        'Return_%': ret * 100
    })

returns_df = pd.DataFrame(returns)

# 4. Performance summary
average_return = returns_df['Return_%'].mean()
total_return = (returns_df['Return_%'] / 100 + 1).prod() - 1

print("TKMS Buy Close → Sell Next Open Strategy")
print(returns_df)
print(f"\nAverage Daily Return: {average_return:.3f}%")
print(f"Cumulative Return (compounded): {total_return*100:.2f}%")

# 5. Plot cumulative performance
returns_df['Cumulative_Value'] = (1 + returns_df['Return_%'] / 100).cumprod()

plt.figure(figsize=(10,6))
plt.plot(returns_df['Sell_Date'], returns_df['Cumulative_Value'], marker='o', linewidth=2)
plt.title('TKMS Buy-at-Close, Sell-Next-Open Strategy Performance')
plt.xlabel('Sell Date')
plt.ylabel('Cumulative Growth (× Starting Capital)')
plt.grid(True)
plt.show()

# 6. Save results
returns_df.to_csv("TKMS_buy_close_sell_open_returns.csv", index=False)
print("\nStrategy complete. Results saved to TKMS_buy_close_sell_open_returns.csv")




#######################################################################
# STEP 1 — BLOOMBERG EXPORT FORMAT (for intraday backtest)
#######################################################################
# In Bloomberg Excel Add-in or via IB <GO>:
# Export 1-minute or 5-minute bars for the last few trading days.

# REQUIRED COLUMNS (exact headers in Excel):
# ------------------------------------------
# Datetime, Price, Volume
#
# Example (CSV rows):
# Datetime,Price,Volume
# 2025-10-20 09:00:00,14.23,1050
# 2025-10-20 09:05:00,14.24,900
# 2025-10-20 16:30:00,14.40,1200
# 2025-10-21 09:00:00,14.42,800
# 2025-10-21 09:05:00,14.50,700
# 2025-10-21 16:30:00,14.78,1000
#
# Save the file as:
#   TKMS_intraday.csv
#
# Ensure the timestamps cover the full trading day (e.g., 09:00–17:30 CET).
#######################################################################


#######################################################################
# STEP 2 — PYTHON / JUPYTER NOTEBOOK CODE
#######################################################################
# Copy and paste everything below into a single Jupyter cell.
# It will:
#   - Read your CSV
#   - Detect daily closes and next-day opens
#   - Simulate buying at the close
#   - Simulate selling at multiple intraday times the next day
#   - Identify which sell time gives the best mean/Sharpe return
#######################################################################

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from datetime import timedelta, time

plt.rcParams['figure.figsize'] = (10,5)

# ======== USER SETTINGS ========
CSV_FILE = "TKMS_intraday.csv"     # Your exported Bloomberg file
INTERVAL_MIN = 5                   # minutes between bars (set to match your export)
MARKET_CLOSE_TIME = time(17, 30)   # Frankfurt/Xetra close
SELL_TARGETS = ["open","30m","60m","90m","120m","10:00","12:00","15:00","close"]
# ================================

# ======== LOAD AND PREPARE DATA ========
df = pd.read_csv(CSV_FILE, parse_dates=['Datetime'])
df = df.rename(columns=str.lower)
df = df.rename(columns={'datetime':'dt'})
df = df.sort_values('dt').reset_index(drop=True)

# sanity checks
if 'price' not in df.columns:
    raise ValueError("CSV must have a column named 'Price' or 'price'.")

df.set_index('dt', inplace=True)
df['date'] = df.index.normalize()

# identify trading days
days = df['date'].unique()
days = pd.to_datetime(days)
days = np.sort(days)

# ======== HELPER FUNCTIONS ========
def parse_offset(target):
    if target.endswith("m"):
        return timedelta(minutes=int(target[:-1]))
    if target.endswith("h"):
        return timedelta(hours=int(target[:-1]))
    return None

def pick_sell_price(nextday_df, target):
    if target == "open":
        return nextday_df['price'].iloc[0]
    if target == "close":
        return nextday_df['price'].iloc[-1]
    td = parse_offset(target)
    if td:
        t0 = nextday_df.index[0]
        ts_target = t0 + td
        later = nextday_df.loc[nextday_df.index >= ts_target]
        return later['price'].iloc[0] if not later.empty else nextday_df['price'].iloc[-1]
    if ":" in target:
        hh, mm = map(int, target.split(":"))
        sel = nextday_df.loc[nextday_df.index.time >= time(hh,mm)]
        return sel['price'].iloc[0] if not sel.empty else nextday_df['price'].iloc[-1]
    return nextday_df['price'].iloc[-1]

# ======== MAIN BACKTEST LOOP ========
records = []
for i in range(len(days)-1):
    day = days[i]
    next_day = days[i+1]
    day_df = df[df['date'] == day]
    next_df = df[df['date'] == next_day]
    if day_df.empty or next_df.empty:
        continue
    # buy at close
    buy_df = day_df[day_df.index.time <= MARKET_CLOSE_TIME]
    if buy_df.empty: 
        continue
    buy_price = buy_df['price'].iloc[-1]
    for target in SELL_TARGETS:
        sell_price = pick_sell_price(next_df, target)
        ret = (sell_price - buy_price) / buy_price
        records.append({
            'buy_date': day,
            'sell_target': target,
            'buy_price': buy_price,
            'sell_price': sell_price,
            'return': ret
        })

res = pd.DataFrame(records)
if res.empty:
    raise ValueError("No valid trading day pairs found. Check CSV coverage or timestamps.")

# ======== ANALYSIS ========
summary = res.groupby('sell_target')['return'].agg(['count','mean','std','median'])
summary['win_rate'] = res.groupby('sell_target')['return'].apply(lambda x: (x>0).mean())
summary['sharpe'] = summary['mean'] / summary['std']
summary = summary.sort_values('mean', ascending=False)

print("\n=== Summary stats by sell time ===")
print(summary.round(6))

# t-tests
print("\nT-tests vs 0:")
for target, grp in res.groupby('sell_target'):
    t, p = stats.ttest_1samp(grp['return'], 0.0)
    print(f"{target:8s}  N={len(grp):3d}  mean={grp['return'].mean():+.5f}  t={t:.3f}  p={p:.4f}")

# ======== PLOTS ========
plt.errorbar(summary.index, summary['mean'], yerr=summary['std'], fmt='o')
plt.axhline(0, color='k', linestyle='--')
plt.title("Mean return by sell time (error bars = std)")
plt.ylabel("Mean return")
plt.xticks(rotation=45)
plt.show()

# Boxplot
res.boxplot(column='return', by='sell_target', rot=45)
plt.suptitle('')
plt.title('Distribution of returns by sell time')
plt.ylabel('Return')
plt.show()

# Cumulative P&L for best target
best = summary.index[0]
cum = res[res['sell_target']==best].sort_values('buy_date')
cum['cum_pnl'] = cum['return'].cumsum()
plt.plot(cum['buy_date'], cum['cum_pnl'], marker='o')
plt.title(f"Cumulative P&L: Buy close → Sell {best}")
plt.ylabel("Cumulative return (units)")
plt.xlabel("Buy date")
plt.grid(True)
plt.show()

print(f"\nBest selling time historically: {best}")
#######################################################################
# END
#######################################################################



Team,

Quick update on TKMS (€76.11) – strong post-spin rally losing momentum, with risk/reward now skewed to the downside.

Trade Plan – TKMS (Thyssenkrupp Marine Systems)
	•	Current: €76.11 (↑27% vs listing €60, ↓29% from €107 peak)
	•	Position: Long
	•	Action: Reduce 50–75% of exposure

Rationale
	•	Valuation stretched – trading well above analyst consensus (€74–75)
	•	Momentum broken – stock down nearly 30% from peak, red on the day
	•	Street cautious: DB €75 (Hold), Bernstein €74 (Underperform), Jefferies €36.55 (Bearish)
	•	Asymmetric risk: +40% to peak vs –25% to listing, –50% to worst case
	•	Better re-entry zone: €60–65

Catalysts to Watch
	•	🇨🇦 Canadian submarine tender (€40B+) – key potential upside trigger
	•	🇮🇳 India P75I submarines, 🇩🇪 F127 frigate program – additional optionality
	•	📈 Margin expansion target: 7%+ (vs 4.3% currently)
	•	💰 Dividend initiation (2027) – medium-term support

Execution Plan
	1.	Trim 50–75% of TKMS position on next open
	2.	Set stop-loss on remaining exposure at €68–70
	3.	Monitor Canadian contract news and defense budget catalysts
	4.	Rebuild exposure on pullback to €60–65

Summary
	•	Book strong post-spin gains while sentiment cools
	•	Maintain partial exposure for long-term defense story

====================================================================================================
TKMS TRADE PITCH: HOLD OR CUT ANALYSIS
====================================================================================================

📊 CURRENT POSITION OVERVIEW
--------------------------------------------------
Position: LONG TKMS
Current Price: €76.11 (Oct 22, 2025)
IPO Price: €60.00 (Oct 20, 2025)
First Day High: €107.00
Performance: +26.9% from IPO, -28.9% from peak
Status: Stock closed DOWN today

📈 FUNDAMENTAL METRICS
--------------------------------------------------
Order Backlog: €18.6 billion
Revenue Visibility: ~9 years
Current EBIT Margin: 4.3%
Target EBIT Margin: >7%
Revenue Growth Target: 10% CAGR
Market Cap (Current): €4.99 billion
Market Cap (IPO): €3.8 billion
First Dividend: 2027
Dividend Payout: 30-50% of net profit

🎯 ANALYST PRICE TARGETS & RATINGS
--------------------------------------------------
Deutsche Bank: €75 (Hold) - 'submarine growth already priced in'
Bernstein: €74 (Underperform) - 'underperformer priced like winner'
Jefferies: €36.55 (Bearish valuation)
Citigroup: €71
Consensus: €74-75 range

Implied Downside from Current (€76.11):
  Deutsche Bank: -1.5%
  Bernstein: -2.8%
  Jefferies: -52.0%
  To IPO Price: -21.2%

🚢 MAJOR CONTRACT PIPELINE
--------------------------------------------------
Canada Submarine Program: $60B CAD (~€40B) - Final 2 bidders
German F127 Frigates: TBD - Multi-billion program
India P75I Submarines: $5.2B - Competing vs Spanish rival
Additional German 212CD: €4.7B - Recently approved
German Sub Modernization: €800M - Already secured

🐂 THE BULL CASE
--------------------------------------------------
✅ Structural European defense boom - spending up 11% in 2024
✅ €18.6B order backlog = 9 years revenue visibility
✅ Multiple mega-contracts in pipeline (Canada €40B+ key catalyst)
✅ Margin expansion story: 4.3% → 7%+ target (270bps upside)
✅ NATO pushing defense spending to 3.5% GDP by 2032
✅ Strong competitive position in submarine/naval systems
✅ First dividend 2027 provides income floor

🐻 THE BEAR CASE
--------------------------------------------------
❌ Valuation stretched: IPO +40-65% above analyst estimates
❌ Analyst consensus bearish: most targets at/below current price
❌ Technical momentum broken: -29% from peak, down today
❌ Margin gap substantial: 270bps to reach peer levels
❌ Competition intensifying (Korean, Turkish shipbuilders)
❌ Production capacity constraints through 2040s
❌ Execution risk on margin expansion over multi-year period
❌ Post-IPO euphoria exhausted, distribution phase begun

⚖️ RISK/REWARD ANALYSIS
--------------------------------------------------
Current Price: €76.11
Upside to Peak: +40.6%
Downside to Analyst Consensus (€74-75): -1.5%
Downside to IPO Price: -26.8%
Worst Case (Jefferies €36.55): -52.0%

Risk/Reward Assessment: ASYMMETRIC TO DOWNSIDE
Limited upside (~40% to peak) vs significant downside risk

🎯 TRADING RECOMMENDATION: CUT 50-75% OF POSITION
--------------------------------------------------

IMMEDIATE ACTION: Reduce TKMS position by 50-75%
RETAIN: 25-50% as long-term conviction play
RATIONALE: Lock in +27% IPO gains while managing downside risk

EXECUTION PLAN:
1. Sell 50-75% tomorrow (already down today)
2. Set stop-loss on remaining at €68-70 
3. Watch for Canadian contract as reload catalyst
4. Consider re-entry at €60-65 if pullback occurs

WHY CUT NOW:
• Risk/reward asymmetric to downside at current levels
• Analyst consensus sees limited upside from here
• Technical momentum broken (-29% from peak)
• Valuation expanded too far, too fast post-IPO
• Better entry points likely coming in 3-6 months

WHY KEEP SOME:
• European defense mega-trend intact
• €18.6B backlog provides earnings visibility  
• Canadian contract could be transformational catalyst
• Margin expansion could surprise positively


🔄 SCENARIOS THAT WOULD VINDICATE STAYING LONG
--------------------------------------------------
🎯 TKMS wins Canadian submarine contract (€40B+ order addition)
📈 Margins accelerate faster than expected toward 7%+ target
🚀 European defense spending accelerates beyond projections
🏆 Major contract wins in India P75I or German F127 programs
💰 Operational leverage drives earnings above consensus

⏰ TIMELINE: These catalysts are months away minimum
❓ QUESTION: Why hold elevated valuation risk while waiting?

====================================================================================================
FINAL VERDICT
====================================================================================================

TKMS at €76 is PRICED FOR PERFECTION after 27% post-IPO rally

✅ WHAT YOU DID RIGHT: Caught IPO momentum, +27% in 3 days
❌ WHAT TO AVOID: Letting a winner turn into a loser

🎯 PROFESSIONAL APPROACH: 
   • Lock in gains on euphoria pop (50-75% reduction)
   • Manage risk with stop-loss on remainder  
   • Reload at better valuation if story intact

📊 RISK MANAGEMENT > HERO SIZING
   The long-term defense story is compelling, but you don't need 
   maximum exposure at stretched multiples with deteriorating technicals.

🔥 BOTTOM LINE: Trade like a professional - take profits, manage risk,
   wait for better entry points. This is risk management, not capitulation.

====================================================================================================








═══════════════════════════════════════════════════════════════════════════════════════
TENDER OFFER & BUYBACK TREATMENT BY INDEX PROVIDER – WITH METHODOLOGY REFERENCES
═══════════════════════════════════════════════════════════════════════════════════════

PROVIDER: FTSE Russell (FTSE 100, FTSE All-Share, FTSE UK Index Series)

Treatment of Tender Offer Buyback:
• Tender offers and UK/Australian tender offer buybacks implemented IMMEDIATELY after 
  prerequisites achieved (completion/confirmation/final results published).
• Intra-quarter implementation occurs if:
  - USD $1 billion investable market cap change (change in index shares × offer price)
  OR
  - 5% change in index shares AND USD $250 million investable market cap change
• UK/AU specific: Due to regulatory requirements, UK companies buying >15% of shares via 
  tender offer and Australian equal-opportunity tender offers implemented upon receipt of 
  results if above thresholds met.
• All OTHER partial voluntary buybacks or partial tenders: quarterly review only.
• Implementation timing: T+2 business days after tender completion/confirmation.
• Weight changes applied proportionally across indices.
• Deletion only if float <5% (unlikely for DCC).

Threshold Documentation:
Section 2.2 of "Quarterly and Intra-Quarter Free Float and Share Updates FAQ" (v3.4, May 2025)
- Page 4-5: Details intra-quarter thresholds for share/float changes
- Page 8: Question 5 specifies UK/AU tender offer treatment and implementation timing
- Page 4-5: "Only share and free float changes resulting from primary offerings...OR 
  secondary offerings...will be implemented where it results in: A USD 1bn investable market 
  cap change...OR A 5% change in index shares AND a USD 250m investable market cap change"
- Page 5: "UK and Australian listed constituents...UK listed companies...required to [buy back] 
  via a tender offer...FTSE Russell will implement the change upon receipt of the tender offer 
  buy back results subject to the above intra-quarter update thresholds being met."

Methodology Links:
• Corporate Actions and Events Guide (Section 4.8 - Compulsory Share Buy Backs): 
  https://www.lseg.com/content/dam/ftse-russell/en_us/documents/policy-documents/corporate-actions-and-events-guide.pdf
• Free Float Maintenance FAQ (Section 2.2 - Intra-quarter updates): 
  https://www.lseg.com/content/dam/ftse-russell/en_us/documents/policy-documents/shares-and-free-float-maintenance-faq.pdf

───────────────────────────────────────────────────────────────────────────────────────

PROVIDER: MSCI (MSCI Europe, MSCI ACWI, MSCI Global Investable Market Indexes)

Treatment of Tender Offer Buyback:
• Partial tender offers and buyback offers implemented INTRA-QUARTER if results represent 
  ≥5%, 10%, or 25% for Standard, Small Cap, and Micro Cap constituents respectively of 
  pre-event number of shares used in MSCI Indexes.
• Implementation occurs TWO BUSINESS DAYS after official communication of results if 
  sufficient information publicly available to determine post-event free float.
• Fixed price offers: PAF of 1 applied on ex-date (or first business day after end of offer if 
  ex-date unavailable).
• Dutch auctions: No PAF applied (price unknown beforehand).
• Number of shares (NOS) and Free Float Factor (FIF) adjusted simultaneously.
• If FIF falls below 0.15 (15%) post-event, constituent faces deletion risk.
• Changes <5%/10%/25% (depending on size segment): deferred to quarterly index review.
• Pending NOS/float updates <±1% on post-event basis: deferred to quarterly review.

Threshold Documentation:
Section 2.4.3 of "MSCI Corporate Events Methodology" (August 2024)
- Page 13-14: "Results of partial tender offers and buyback offers"
- Page 13: "After the results of the offer have been officially communicated, and if 
  sufficient information is publicly available to determine the post-event free float, then any 
  changes in number of shares and FIF and/or DIF are implemented with two full business days 
  advance notification, if results of the offer represents at least 5%, 10% or 25% for Standard 
  constituents...Small Caps constituents...and Micro Caps constituents...respectively of the 
  security's pre-event number of shares used in MSCI Indexes."
- Page 13: "Changes in number of shares following the actual cancellation of the shares and 
  changes that do not meet the criteria for implementation at the time of the event...are 
  implemented at the next regularly scheduled Index Review"

Methodology Links:
• MSCI Corporate Events Methodology (Section 2.4 - Partial tender offers and buyback offers): 
  https://www.msci.com/indexes/documents/methodology/0_MSCI_Corporate_Events_Methodology_20240812.pdf
• MSCI Global Investable Market Indexes Methodology: 
  https://www.msci.com/indexes/documents/methodology/1_MSCI_Global_Investable_Market_Indexes_Methodology_20240812.pdf

───────────────────────────────────────────────────────────────────────────────────────

PROVIDER: S&P Dow Jones Indices (S&P UK, S&P Global Indices)

Treatment of Tender Offer Buyback:
• Dutch auctions, self-tender offer buybacks, and split-off exchanges eligible for ACCELERATED 
  IMPLEMENTATION regardless of size once final results publicly announced.
• Standard tender offers: Changes implemented if ≥5% shares outstanding AND ≥USD $150 million.
• Implementation timing: 1-2 business days' notice from announcement (1 day US-domiciled, 
  2 days non-US).
• Share count and Investable Weight Factor (IWF) changes implemented together if IWF changes 
  by ≥5 percentage points.
• Changes <5% of shares outstanding: deferred to quarterly rebalancing unless ≥USD $1 billion.
• Target Security Float Change section 1.c and 1.d (page 7) specifies thresholds.

Threshold Documentation:
Section "Non-Mandatory Share and IWF Updates" → "Material Share/IWF Changes" (page 14)
- Page 7: "Target Security Float Change" subsection details tender offer implementation rules
- Page 7, Condition 1.d: "Size of the change is at least 5% and US$ 150 million or US$ 1 billion"
- Page 7, Condition 2.d: "Size of the change is at least US$ 1 billion or IWF changes by at 
  least 15%"
- Page 14: "Dutch Auctions, Self-tender offer buybacks, and Split-off exchange offers" 
  section confirms accelerated implementation "regardless of size"

Methodology Links:
• S&P DJI Equity Indices Policies & Practices (Section on M&A and Non-Mandatory Updates): 
  https://www.spglobal.com/spdji/en/documents/methodologies/methodology-sp-equity-indices-policies-practices.pdf
• S&P Index Math Methodology: 
  https://www.spglobal.com/spdji/en/documents/methodologies/methodology-index-math.pdf

───────────────────────────────────────────────────────────────────────────────────────

PROVIDER: STOXX (EURO STOXX 50, STOXX Europe 600, STOXX Indices)

Treatment of Tender Offer Buyback:
• Corporate actions including tender offers handled per STOXX corporate action rules.
• Large float shifts (typically >5%) trigger intra-quarter weight adjustments.
• Share count and float adjustments coordinated with settlement dates and exchange 
  notifications.
• Free-float market cap weighting maintained with maximum constituent weight caps.
• Implementation occurs immediately upon completion with appropriate notice.

Threshold Documentation:
No specific public documentation found detailing exact percentage thresholds. STOXX 
methodologies reference "material changes" and typically align with 5% threshold common 
across industry but specific documented thresholds not publicly specified in reviewed materials.

Methodology Links:
• STOXX Calculation Guide (general methodology - search specific index on site): 
  https://www.stoxx.com/index-details
• STOXX Corporate Actions Framework (consult specific index methodology documents)

───────────────────────────────────────────────────────────────────────────────────────

PROVIDER: Solactive (Various Custom and Thematic Indices)

Treatment of Tender Offer Buyback:
• Tender offers implemented from cum-day to ex-day to coincide with price effect.
• Germany, Switzerland, Austria markets: If tendered shares trade separately, Solactive may 
  replace common share line with tendered line if ALL four conditions met:
  a) Minimum acceptance level requirement met
  b) At least 50% of shares held by acquirer
  c) Additional offer period (not extension) launched
  d) Tendered shares continue trading after additional offer period expires
• Index adjustments announced with minimum TWO BUSINESS DAYS' notice.
• Solactive retains discretion for unusual/complex actions to preserve index integrity.
• Implementation effective on specified date in announcement.

Threshold Documentation:
Section 3.2 "Timing of Adjustment" (pages 7-8) of "Guideline for Extraordinary Corporate Actions" 
(Version 1.4, October 2024)
- Page 7: Lists conditions a), b), c) for implementation
- Page 7-8: "An adjustment will be applied to the Index when: a) the Extraordinary Event leads 
  to a DELISTING...b) the acquiring company initiates a squeeze-out procedure...c) the results 
  of the tender offer or shareholder meeting are announced, the offer is successful, and 
  unconditional and the resulting free float of the target company is set to drop below 15%."
- Page 8: "In Certain markets (e.g. Germany, Switzerland and Austria)...replace the common 
  share line, with the tendered line...if the below conditions are satisfied: a) The minimum 
  acceptance level requirement is met b) At least 50% of the total shares would be held by 
  acquiror c) An additional offer period (not an extension) is launched."

Methodology Links:
• Solactive Extraordinary Corporate Actions Guideline (Section 3 - Mergers & Acquisitions): 
  https://www.solactive.com/wp-content/uploads/2018/01/ECA-Guideline-change-_v1.4_03October24_FINAL.pdf
• Solactive Equity Index Methodology: 
  https://www.solactive.com/documents/equity-index-methodology/

═══════════════════════════════════════════════════════════════════════════════════════
SUMMARY FOR DCC £600M TENDER (~12% OF FLOAT)
═══════════════════════════════════════════════════════════════════════════════════════

All major providers will implement DCC's tender INTRA-QUARTER as the 12% float reduction 
exceeds all materiality thresholds:

✓ FTSE: Exceeds 5% + $250M threshold → Immediate T+2 implementation
✓ MSCI: Exceeds 5% threshold for Standard constituents → +2 business days implementation
✓ S&P DJI: Likely exceeds 5% + $150M threshold → 1-2 day notice implementation
✓ STOXX: Exceeds typical 5% threshold → 2-3 day notice implementation  
✓ Solactive: Meets 2-day notice requirements → Implementation per index rules

No Deletion Risk: DCC remains in all indices; only weights/shares adjusted.

═══════════════════════════════════════════════════════════════════════════════════════






Provider: FTSE Russell (FTSE UK Index Series)
Treatment:
- Updates to shares in issue and free float triggered by material float changes. Can occur intra-quarter if thresholds are met.
- Implementation typically within two business days after event confirmation (T+2).
- Notices and detailed methodology published in official FTSE Russell materials.
Key links (methodology / notices):
- FTSE Russell Free Float Restrictions: https://www.lseg.com/content/dam/ftse-russell/en_us/documents/policy-documents/free-float-restrictions.pdf
- Free Float Maintenance FAQ (Quarterly and Intra-Quarter): https://www.lseg.com/content/dam/ftse-russell/en_us/documents/policy-documents/shares-and-free-float-maintenance-faq.pdf
- Guide to Calculation Methods for the FTSE UK Index Series: https://www.lseg.com/content/dam/ftse-russell/en_us/documents/ground-rules/ftse-uk-index-series-guide-to-calc.pdf
- FTSE Russell Index Notices / Market Consultations: https://www.lseg.com/en/ftse-russell/governance/market-consultations

Provider: MSCI (MSCI Europe / MSCI ACWI / Global Indices)
Treatment:
- Float and shares outstanding changes updated via corporate actions methodology.
- Large float reductions trigger updates to counts and weights; possible membership/removal if thresholds breached.
- Implementation usually two business days after completion of the corporate action/final results.
Key links (methodology / notices):
- MSCI Corporate Events Methodology (general): https://www.msci.com/documents/1296102/1331873/Partial_Tender_Offers_March2012.pdf
- MSCI Corporate Events Methodology (latest): https://www.msci.com/documents/1296102/1311232/MSCI+Methodology+Documents.pdf
- MSCI Index Calculation Methodology: https://www.msci.com/indexes/documents/methodology/0_MSCI_Index_Calculation_Methodology_20240812.pdf
- MSCI Methodology overview: https://www.msci.com/eqb/methodology/meth_docs/MSCI_CEMethodology_Feb2020.pdf

Provider: S&P Dow Jones Indices (S&P DJI)
Treatment:
- Corporate actions and free float changes handled per S&P DJI methodologies.
- Tender-like float changes typically lead to index weight adjustments following final results.
- Updates align with S&P DJI calendars and notices; not strictly tied to quarterly reviews.
Key links (methodology / notices):
- S&P Dow Jones Indices Methodology (Index Math / Float): https://www.spglobal.com/spdji/en/documents/methodologies/methodology-index-math.pdf
- S&P DJI Corporate Actions Handbook (policy context): https://www.spglobal.com/spdji/es/documents/methodologies/methodology-index-math.pdf (see relevant sections)

Provider: STOXX (STOXX indices)
Treatment:
- Corporate actions and float changes managed under STOXX rules.
- Large float shifts can trigger intra-quarter updates if thresholds are satisfied.
- Notices specify exact effective dates and weight adjustments.
Key links (methodology / notices):
- STOXX corporate actions / float guidelines (typical framework): https://www.stoxx.com/hubfs/Whitepapers/2024%20Whitepapers/STOXX_WP_Understanding_Investor_Preferences_through_Passive_Investment_Flows_2024Apr.pdf
- STOXX calculation / methodology overview: https://www.spglobal.com/spdji/es/documents/methodologies/methodology-index-math.pdf

Provider: Solactive (requested)
Treatment:
- Solactive follows standard corporate action rules for free float and share changes.
- Implementations typically occur in line with local market conventions and partner ETF/portfolio rebalancing calendars.
Key links (methodology / notices):
- Solactive methodology overview (general): https://www.solactive.com/how-we-calculate/
- Solactive index methodology specifics (searchable on site for “float” / “tender” updates)

Notes for quick reference
- Intra-quarter updates are common when float or share counts cross material thresholds; exact thresholds and timing are defined in each provider’s official documents.
- Post-event implementation usually occurs within 2 business days of confirmation, but always verify the latest notices for the precise date and any prorations or special cases.
- Always cross-check the official index notices for the tender to confirm whether a deletion risk exists and to extract the exact effective date and weights.

If you want, I can tailor this into a one-page briefing with a compact checklist and a ready-to-share executive summary, plus a live template for recording the tender’s expected impact against each index family. 



# ----------------------------
# DCC Tender Offer Scenario Analysis
# ----------------------------
# Expected CSV structure (../Tender_Offer_Analysis /DCC_Data.csv):
# Columns: Metric, Value
# Example rows:
# TICKER, DCC LN
# TENDER_OFFER, 600000000
# CUR_MKT_CAP, 6200000000
# EQY_SH_OUT, 100000000
# PX_LAST, 5500
# 20_DAY_AVERAGE_VOLUME_AT_TIME, 200000
# EQY_FREE_FLOAT_PCT, 58
# UKX, 0.19
# ASX, 0.07
#
# Notes:
# - PX_LAST is in pence; will be converted to pounds.
# - TENDER_OFFER is in pounds.
# - EQY_SH_OUT and volume are in shares.
# - Index weights (e.g., UKX, ASX) are in % (e.g., 0.19 means 0.19%).
# ----------------------------

import pandas as pd

# File path
file_path = "../Tender_Offer_Analysis /DCC_Data.csv"

# Read vertical CSV and convert to dict
df = pd.read_csv(file_path)
data = pd.Series(df.Value.values, index=df.Metric).to_dict()

# Core metrics
ticker = data["TICKER"]
tender_offer_gbp = float(data["TENDER_OFFER"])
mcap = float(data["CUR_MKT_CAP"])
shares_out = float(data["EQY_SH_OUT"])
px_last_pence = float(data["PX_LAST"])
avg_vol = float(data["20_DAY_AVERAGE_VOLUME_AT_TIME"])
free_float = float(data["EQY_FREE_FLOAT_PCT"]) / 100

# Convert price from pence to pounds
px_last = px_last_pence / 100

# Identify all index weights (e.g., UKX, ASX)
core_metrics = ["TICKER","TENDER_OFFER","CUR_MKT_CAP","EQY_SH_OUT","PX_LAST",
                "20_DAY_AVERAGE_VOLUME_AT_TIME","EQY_FREE_FLOAT_PCT"]
index_metrics = [m for m in data.keys() if m not in core_metrics]

# Convert index weights to fractions
index_weights = {idx: float(data[idx]) / 100 for idx in index_metrics}

# Define tender premium/discount scenarios
premiums = [-0.10, -0.05, 0.00, 0.05, 0.10, 0.15]

results = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_offer_gbp / tender_price
    new_shares_out = shares_out - shares_redeemed
    share_reduction_pct = (shares_redeemed / shares_out) * 100

    # Free float and free-float market cap
    new_free_float = free_float * (1 - (shares_redeemed / shares_out))
    new_mcap = new_shares_out * tender_price
    old_ff_mcap = mcap * free_float
    new_ff_mcap = new_mcap * new_free_float

    for idx, old_weight in index_weights.items():
        old_weight_frac = old_weight
        # Adjust weights based on free-float market cap
        new_weight_frac = old_weight_frac * (new_ff_mcap / old_ff_mcap)
        abs_change_bps = (new_weight_frac - old_weight_frac) * 10000  # in bps

        results.append({
            "Ticker": ticker,
            "Tender Premium": f"{int(p*100)}%",
            "Tender Price (£)": round(tender_price, 2),
            "Index": idx,
            "Old Weight (%)": round(old_weight_frac * 100, 4),
            "New Weight (%)": round(new_weight_frac * 100, 4),
            "Absolute Weight Change (bps)": round(abs_change_bps, 2),
            "Share Reduction (%)": round(share_reduction_pct, 2),
            "New Free Float (%)": round(new_free_float * 100, 2),
            "New Free-Float Mkt Cap (£bn)": round(new_ff_mcap / 1e9, 2)
        })

# Combine results
scenarios_df = pd.DataFrame(results)

# Save results to CSV
output_path = "../Tender_Offer_Analysis /DCC_Index_Weight_Changes.csv"
scenarios_df.to_csv(output_path, index=False)

# Display filtered results if desired
# e.g., to see just UKX results:
selected_index = "UKX"
filtered_df = scenarios_df[scenarios_df["Index"] == selected_index]

print(f"\nResults saved to: {output_path}")
print(f"\nFiltered results for {selected_index}:")
display(filtered_df)


# ================================================================
# DCC £600mn Tender Offer — Multi-Index Scenario Analysis with CSV export, discounts & selected indexes
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# Step 0: Specify selected indexes (empty = all indexes)
# -----------------------------
selected_indexes = ['ASX', 'UKX']  # put empty list [] to include all indexes

# -----------------------------
# Step 1: Load vertical CSV
# -----------------------------
file_path = "../Tender_Offer_Analysis /DCC_Data.csv"  # note the space after folder
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# -----------------------------
# Step 2: Extract company fundamentals
# -----------------------------
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])          # in £
mcap = float(data['CUR_MKT_CAP'])                  # in £
shares_out = float(data['EQY_SH_OUT'])             # number of shares
px_last_pence = float(data['PX_LAST'])             # in pence
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])  # shares
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100   # fraction

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# -----------------------------
# Step 3: Identify index weights dynamically
# -----------------------------
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

index_metrics = [k for k in data.keys() if k not in fundamentals]

# Filter for selected indexes
if selected_indexes:
    index_metrics = [idx for idx in index_metrics if idx in selected_indexes]

# Convert percentages to fractions
index_weights = {idx: float(data[idx])/100 for idx in index_metrics}

# -----------------------------
# Step 4: Scenario Analysis including discounts
# -----------------------------
premiums = [-0.05, 0.0, 0.05, 0.10, 0.15]  # include -5% discount
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity
    volume_multiple = shares_redeemed / avg_vol

    # 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight_frac in index_weights.items():
        new_weight = weight_frac * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight_frac) / weight_frac * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,5)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],3)

    scenarios.append(scenario_result)

# -----------------------------
# Step 5: Create DataFrame
# -----------------------------
scenarios_df = pd.DataFrame(scenarios)

# -----------------------------
# Step 6: Display nicely in Jupyter
# -----------------------------
pd.options.display.float_format = '{:,.2f}'.format
display(scenarios_df)

# Highlight negative changes in red
def highlight_negative(val):
    try:
        return 'color: red' if float(val) < 0 else 'color: green'
    except:
        return ''

styled_df = scenarios_df.style.applymap(highlight_negative, subset=[col for col in scenarios_df.columns if 'Change' in col])
display(styled_df)

# -----------------------------
# Step 7: Export to CSV
# -----------------------------
output_path = "../Tender_Offer_Analysis /DCC_Tender_Scenarios.csv"
scenarios_df.to_csv(output_path, index=False)
print(f"Scenario table exported to {output_path}")

# -----------------------------
# Step 8: Visualization
# -----------------------------
# Bar chart for share reduction
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

# Heatmap for selected index weight changes
index_change_cols = [col for col in scenarios_df.columns if 'Change (%)' in col and col not in ['Share Reduction (%)','Market Cap Change (%)','Free Float Change (%)']]
plt.figure(figsize=(10,len(premiums)*0.7+2))
sns.heatmap(scenarios_df[index_change_cols], annot=True, fmt=".2f", cmap="coolwarm", cbar_kws={'label':'% Change'})
plt.title(f"{ticker} — Selected Index Weight Changes by Tender Premium")
plt.xlabel("Index")
plt.ylabel("Scenario (Premium)")
plt.show()

print("Analysis complete.")




# ================================================================
# DCC £600mn Tender Offer — Multi-Index Scenario Analysis with CSV export & discounts
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# Step 1: Load vertical CSV
# -----------------------------
file_path = "../Tender_Offer_Analysis /DCC_Data.csv"  # note the space after folder
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# -----------------------------
# Step 2: Extract company fundamentals
# -----------------------------
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])          # in £
mcap = float(data['CUR_MKT_CAP'])                  # in £
shares_out = float(data['EQY_SH_OUT'])             # number of shares
px_last_pence = float(data['PX_LAST'])             # in pence
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])  # shares
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100   # fraction

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# -----------------------------
# Step 3: Identify index weights dynamically
# -----------------------------
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

index_metrics = [k for k in data.keys() if k not in fundamentals]
# Convert percentages to fractions
index_weights = {idx: float(data[idx])/100 for idx in index_metrics}

# -----------------------------
# Step 4: Scenario Analysis including discounts
# -----------------------------
premiums = [-0.05, 0.0, 0.05, 0.10, 0.15]  # include -5% discount
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity
    volume_multiple = shares_redeemed / avg_vol

    # 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight_frac in index_weights.items():
        new_weight = weight_frac * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight_frac) / weight_frac * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,5)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],3)

    scenarios.append(scenario_result)

# -----------------------------
# Step 5: Create DataFrame
# -----------------------------
scenarios_df = pd.DataFrame(scenarios)

# -----------------------------
# Step 6: Display nicely in Jupyter
# -----------------------------
pd.options.display.float_format = '{:,.2f}'.format
display(scenarios_df)

# Highlight negative changes in red
def highlight_negative(val):
    try:
        return 'color: red' if float(val) < 0 else 'color: green'
    except:
        return ''

styled_df = scenarios_df.style.applymap(highlight_negative, subset=[col for col in scenarios_df.columns if 'Change' in col])
display(styled_df)

# -----------------------------
# Step 7: Export to CSV
# -----------------------------
output_path = "../Tender_Offer_Analysis /DCC_Tender_Scenarios.csv"
scenarios_df.to_csv(output_path, index=False)
print(f"Scenario table exported to {output_path}")

# -----------------------------
# Step 8: Visualization
# -----------------------------
# Bar chart for share reduction
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

# Heatmap for index weight changes
index_change_cols = [col for col in scenarios_df.columns if 'Change (%)' in col and col not in ['Share Reduction (%)','Market Cap Change (%)','Free Float Change (%)']]
plt.figure(figsize=(10,len(premiums)*0.7+2))
sns.heatmap(scenarios_df[index_change_cols], annot=True, fmt=".2f", cmap="coolwarm", cbar_kws={'label':'% Change'})
plt.title(f"{ticker} — Index Weight Changes by Tender Premium")
plt.xlabel("Index")
plt.ylabel("Scenario (Premium)")
plt.show()

print("Analysis complete.")



# ================================================================
# DCC £600mn Tender Offer — Full Scenario Analysis with Export & Visualization
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# Step 1: Load vertical CSV
# -----------------------------
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# -----------------------------
# Step 2: Extract company fundamentals
# -----------------------------
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])          # in £
mcap = float(data['CUR_MKT_CAP'])                  # in £
shares_out = float(data['EQY_SH_OUT'])             # number of shares
px_last_pence = float(data['PX_LAST'])             # in pence
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])  # shares
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100   # fraction

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# -----------------------------
# Step 3: Identify index weights dynamically
# -----------------------------
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

index_metrics = [k for k in data.keys() if k not in fundamentals]
# Convert percentages to fractions
index_weights = {idx: float(data[idx])/100 for idx in index_metrics}

# -----------------------------
# Step 4: Scenario Analysis
# -----------------------------
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, 5%, 10%, 15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity
    volume_multiple = shares_redeemed / avg_vol

    # 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight_frac in index_weights.items():
        new_weight = weight_frac * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight_frac) / weight_frac * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,5)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],3)

    scenarios.append(scenario_result)

# -----------------------------
# Step 5: Create DataFrame
# -----------------------------
scenarios_df = pd.DataFrame(scenarios)

# -----------------------------
# Step 6: Display nicely in Jupyter
# -----------------------------
pd.options.display.float_format = '{:,.2f}'.format
display(scenarios_df)

# Highlight negative changes in red
def highlight_negative(val):
    try:
        return 'color: red' if float(val) < 0 else 'color: green'
    except:
        return ''

styled_df = scenarios_df.style.applymap(highlight_negative, subset=[col for col in scenarios_df.columns if 'Change' in col])
display(styled_df)

# -----------------------------
# Step 7: Export to Excel
# -----------------------------
output_path = "../Tender_Offer_Analysis/DCC_Tender_Scenarios.xlsx"
scenarios_df.to_excel(output_path, index=False)
print(f"Scenario table exported to {output_path}")

# -----------------------------
# Step 8: Visualization
# -----------------------------
# Bar chart for share reduction
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

# Heatmap for index weight changes
index_change_cols = [col for col in scenarios_df.columns if 'Change (%)' in col and col not in ['Share Reduction (%)','Market Cap Change (%)','Free Float Change (%)']]
plt.figure(figsize=(10,len(premiums)*0.7+2))
sns.heatmap(scenarios_df[index_change_cols], annot=True, fmt=".2f", cmap="coolwarm", cbar_kws={'label':'% Change'})
plt.title(f"{ticker} — Index Weight Changes by Tender Premium")
plt.xlabel("Index")
plt.ylabel("Scenario (Premium)")
plt.show()

print("Analysis complete.")



# ================================================================
# DCC £600mn Tender Offer — Multi-Index Scenario Analysis (Percent Weights)
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Load vertical CSV ---
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# --- Step 2: Extract base company values ---
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])          # in £
mcap = float(data['CUR_MKT_CAP'])                  # in £
shares_out = float(data['EQY_SH_OUT'])             # number of shares
px_last_pence = float(data['PX_LAST'])             # in pence
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])  # shares
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100   # fraction

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# --- Step 3: Identify index weights dynamically ---
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

# Indexes = any metric not in fundamentals
index_metrics = [k for k in data.keys() if k not in fundamentals]

# Convert percentages to fractions for calculations
index_weights = {idx: float(data[idx])/100 for idx in index_metrics}

# --- Step 4: Scenario Analysis for Different Premiums ---
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, 5%, 10%, 15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)                        # £ per share
    shares_redeemed = tender_value / tender_price           # shares repurchased
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Adjusted market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Adjust free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity proxy: days of average 20-day volume
    volume_multiple = shares_redeemed / avg_vol

    # FTSE 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight_frac in index_weights.items():
        new_weight = weight_frac * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight_frac) / weight_frac * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,5)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],3)

    scenarios.append(scenario_result)

# --- Step 5: Display results ---
scenarios_df = pd.DataFrame(scenarios)
print(f"\n{ticker} — £{tender_value/1e6:.0f}mn Tender Offer Scenario Analysis with Multiple Indexes\n")
display(scenarios_df)

# --- Step 6: Simple Visualization of Share Reduction ---
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

print("Analysis complete.")



# ================================================================
# DCC £600mn Tender Offer — Multi-Index Scenario Analysis (Percent Weights)
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Load vertical CSV ---
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# --- Step 2: Extract base company values ---
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])          # in £
mcap = float(data['CUR_MKT_CAP'])                  # in £
shares_out = float(data['EQY_SH_OUT'])             # number of shares
px_last_pence = float(data['PX_LAST'])             # in pence
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])  # shares
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100   # fraction

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# --- Step 3: Identify index weights dynamically ---
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

# Indexes = any metric not in fundamentals
index_metrics = [k for k in data.keys() if k not in fundamentals]

# Convert percentages to fractions for calculations
index_weights = {idx: float(data[idx])/100 for idx in index_metrics}

# --- Step 4: Scenario Analysis for Different Premiums ---
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, 5%, 10%, 15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)                        # £ per share
    shares_redeemed = tender_value / tender_price           # shares repurchased
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Adjusted market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Adjust free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity proxy: days of average 20-day volume
    volume_multiple = shares_redeemed / avg_vol

    # FTSE 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight_frac in index_weights.items():
        new_weight = weight_frac * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight_frac) / weight_frac * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,5)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],3)

    scenarios.append(scenario_result)

# --- Step 5: Display results ---
scenarios_df = pd.DataFrame(scenarios)
print(f"\n{ticker} — £{tender_value/1e6:.0f}mn Tender Offer Scenario Analysis with Multiple Indexes


# ================================================================
# DCC £600mn Tender Offer — Scenario Analysis with Multiple Indexes
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Load vertical CSV ---
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary using exact column names
data = dict(zip(df['Metric'], df['Value']))

# --- Step 2: Extract base company values ---
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])
mcap = float(data['CUR_MKT_CAP'])
shares_out = float(data['EQY_SH_OUT'])
px_last_pence = float(data['PX_LAST'])
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100

# Convert PX_LAST to pounds
px_last = px_last_pence / 100

# --- Step 3: Identify index weights dynamically ---
fundamentals = ['TICKER','TENDER_OFFER','CUR_MKT_CAP','EQY_SH_OUT','PX_LAST',
                '20_DAY_AVERAGE_VOLUME_AT_TIME','EQY_FREE_FLOAT_PCT']

# Indexes = any metric not in fundamentals
index_metrics = [k for k in data.keys() if k not in fundamentals]
index_weights = {idx: float(data[idx]) for idx in index_metrics}

# --- Step 4: Scenario Analysis for Different Premiums ---
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, 5%, 10%, 15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Adjusted market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Adjust free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity proxy: days of average volume
    volume_multiple = shares_redeemed / avg_vol

    # FTSE 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    # Index weight changes
    new_index_weights = {}
    index_changes = {}
    for idx, weight in index_weights.items():
        new_weight = weight * (new_mcap * new_free_float) / (mcap * free_float)
        change_pct = (new_weight - weight) / weight * 100
        new_index_weights[idx] = new_weight
        index_changes[idx] = change_pct

    # Combine results
    scenario_result = {
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Free Float Change (%)": round(float_change_pct,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    }

    # Add dynamic index columns
    for idx in index_metrics:
        scenario_result[f"{idx} New Weight (%)"] = round(new_index_weights[idx]*100,3)
        scenario_result[f"{idx} Change (%)"] = round(index_changes[idx],2)

    scenarios.append(scenario_result)

# --- Step 5: Display results ---
scenarios_df = pd.DataFrame(scenarios)
print(f"\n{ticker} — £{tender_value/1e6:.0f}mn Tender Offer Scenario Analysis with Index Weights\n")
display(scenarios_df)

# --- Step 6: Simple Visualization of Share Reduction ---
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

print("Analysis complete.")


# ================================================================
# DCC £600mn Tender Offer — Scenario Analysis (Capitalized CSV)
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Load vertical CSV ---
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Check column names
print("Columns in CSV:", df.columns.tolist())

# Convert vertical layout into dictionary using exact column names
data = dict(zip(df['Metric'], df['Value']))

# --- Step 2: Extract base values ---
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])
mcap = float(data['CUR_MKT_CAP'])
shares_out = float(data['EQY_SH_OUT'])
px_last = float(data['PX_LAST'])
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100

# --- Step 3: Scenario Analysis for Different Premiums ---
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, +5%, +10%, +15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Adjusted market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Adjust free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity proxy: days of average volume
    volume_multiple = shares_redeemed / avg_vol

    # FTSE 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    scenarios.append({
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    })

# --- Step 4: Display results ---
scenarios_df = pd.DataFrame(scenarios)
print(f"\n{ticker} — £{tender_value/1e6:.0f}mn Tender Offer Scenario Analysis\n")
display(scenarios_df)

# --- Step 5: Simple Visualization ---
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

print("Analysis complete.")




# ================================================================
# DCC £600mn Tender Offer — Vertical CSV Layout Scenario Analysis
# ================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Load vertical CSV ---
file_path = "../Tender_Offer_Analysis/DCC_Data.csv"
df = pd.read_csv(file_path)

# Convert vertical layout into dictionary
data = dict(zip(df['Metric'], df['Value']))

# --- Step 2: Extract base values ---
ticker = data.get('TICKER', 'DCC')
tender_value = float(data['TENDER_OFFER'])
mcap = float(data['CUR_MKT_CAP'])
shares_out = float(data['EQY_SH_OUT'])
px_last = float(data['PX_LAST'])
avg_vol = float(data['20_DAY_AVERAGE_VOLUME_AT_TIME'])
free_float = float(data['EQY_FREE_FLOAT_PCT']) / 100

# --- Step 3: Scenario Analysis for Different Premiums ---
premiums = [0.0, 0.05, 0.10, 0.15]  # 0%, +5%, +10%, +15%
scenarios = []

for p in premiums:
    tender_price = px_last * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = shares_out - shares_redeemed
    share_reduction_pct = shares_redeemed / shares_out * 100

    # Adjusted market cap
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - mcap) / mcap * 100

    # Adjust free float
    new_free_float = free_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_free_float - free_float) / free_float * 100

    # Liquidity proxy: days of average volume
    volume_multiple = shares_redeemed / avg_vol

    # FTSE 25% free float threshold
    below_threshold = new_free_float * 100 < 25

    scenarios.append({
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price,2),
        "Shares Repurchased (mn)": round(shares_redeemed/1e6,2),
        "Share Reduction (%)": round(share_reduction_pct,2),
        "New Market Cap (£bn)": round(new_mcap/1e9,2),
        "Market Cap Change (%)": round(mcap_change_pct,2),
        "New Free Float (%)": round(new_free_float*100,2),
        "Days of Volume Tendered": round(volume_multiple,1),
        "Below 25% Threshold?": "Yes" if below_threshold else "No"
    })

# --- Step 4: Display results ---
scenarios_df = pd.DataFrame(scenarios)
print(f"\n{ticker} — £{tender_value/1e6:.0f}mn Tender Offer Scenario Analysis\n")
display(scenarios_df)

# --- Step 5: Simple Visualization ---
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title(f"{ticker} £{tender_value/1e6:.0f}mn Tender Offer — Share Reduction by Premium")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

print("Analysis complete.")


# ================================================================
# DCC £600mn Tender Offer — Forward-Looking Scenario Analysis
# ================================================================
# PURPOSE:
# This script models the potential impact of DCC's announced £600mn tender offer
# (expected to occur later this year) on:
#   1. Market capitalisation
#   2. Shares outstanding
#   3. Free float percentage
#   4. FTSE index weight (approximate)
#
# You only need to provide a *current snapshot* of company data in a CSV file.
#
# ================================================================
# REQUIRED INPUT FILE (exact format)
# ================================================================
# Save a CSV file named: dcc_snapshot.csv
#
# Columns (headers exactly as shown, one row only):
#   PX_LAST,MarketCap,SharesOut,FreeFloat,IndexWeight
#
# Example:
#   4725,5000000000,98000000,85,0.23
#
# Notes:
# - PX_LAST: Current share price in £
# - MarketCap: Current total market capitalisation in GBP
# - SharesOut: Current total shares outstanding
# - FreeFloat: Free float percentage (e.g. 85 for 85%)
# - IndexWeight: Current FTSE index weight in % (optional but recommended)
#
# Then run this cell and upload the CSV when prompted.
# ================================================================

import pandas as pd
import numpy as np
from IPython.display import display
from ipywidgets import FileUpload
import io
import matplotlib.pyplot as plt

# --- Step 1: Upload CSV ---
print("Upload your 'dcc_snapshot.csv' file below (1 row of current data).")
uploader = FileUpload(accept='.csv', multiple=False)
display(uploader)

def load_uploaded_file(uploader):
    if len(uploader.value) == 0:
        raise ValueError("No file uploaded. Please upload your 'dcc_snapshot.csv' file.")
    upload = list(uploader.value.values())[0]
    df = pd.read_csv(io.BytesIO(upload['content']))
    print(f"Loaded: {upload['metadata']['name']}")
    return df

if len(uploader.value) == 0:
    raise SystemExit("Upload your CSV file above, then re-run this cell.")

df = load_uploaded_file(uploader)

# --- Step 2: Extract Base Data ---
base = df.iloc[0]
base_price = base['PX_LAST']
base_mcap = base['MarketCap']
base_shares = base['SharesOut']
base_float = base['FreeFloat'] / 100
base_index_weight = base.get('IndexWeight', np.nan)

tender_value = 600_000_000  # £600mn

# --- Step 3: Define Tender Price Scenarios ---
premiums = [0.0, 0.05, 0.10, 0.15]  # No premium, +5%, +10%, +15%
scenarios = []

for p in premiums:
    tender_price = base_price * (1 + p)
    shares_redeemed = tender_value / tender_price
    new_shares = base_shares - shares_redeemed
    share_reduction_pct = shares_redeemed / base_shares * 100

    # Adjusted market cap after tender (using tender price)
    new_mcap = tender_price * new_shares
    mcap_change_pct = (new_mcap - base_mcap) / base_mcap * 100

    # Adjust free float proportionally
    new_float = base_float * (1 - share_reduction_pct / 100)
    float_change_pct = (new_float - base_float) / base_float * 100

    # Adjust FTSE weight proportionally
    if not np.isnan(base_index_weight):
        new_index_weight = base_index_weight * (new_mcap / base_mcap) * (new_float / base_float)
        index_change_pct = (new_index_weight - base_index_weight) / base_index_weight * 100
    else:
        new_index_weight = np.nan
        index_change_pct = np.nan

    # Flag if free float falls below FTSE minimum (25%)
    below_threshold = new_float * 100 < 25

    scenarios.append({
        "Tender Premium": f"{int(p*100)}%",
        "Tender Price (£)": round(tender_price, 2),
        "Shares Repurchased (mn)": round(shares_redeemed / 1e6, 2),
        "Share Reduction (%)": round(share_reduction_pct, 2),
        "New Market Cap (£bn)": round(new_mcap / 1e9, 2),
        "Market Cap Change (%)": round(mcap_change_pct, 2),
        "New Free Float (%)": round(new_float * 100, 2),
        "Below 25% Threshold?": "Yes" if below_threshold else "No",
        "New Index Weight (%)": round(new_index_weight, 3) if not np.isnan(new_index_weight) else None,
        "Index Weight Change (%)": round(index_change_pct, 2) if not np.isnan(index_change_pct) else None
    })

scenarios_df = pd.DataFrame(scenarios)
display(scenarios_df)

# --- Step 4: Simple Visualisation ---
plt.figure(figsize=(8,5))
plt.bar(scenarios_df["Tender Premium"], scenarios_df["Share Reduction (%)"], color='steelblue')
plt.title("DCC Tender Offer — Share Reduction by Premium Scenario")
plt.xlabel("Tender Premium")
plt.ylabel("Share Reduction (%)")
plt.grid(True, axis='y')
plt.show()

print("Scenario analysis complete.")

# ================================================================
# 📊 DCC Tender Offer Analysis — All-in-One Jupyter Notebook Code
# ================================================================
# PURPOSE:
# Analyse the £600mn DCC tender offer (Nov–Dec 2024) to estimate
# share repurchase impact, market cap effects, and FTSE index implications.
#
# INSTRUCTIONS:
# 1️⃣ Export daily data from Bloomberg for DCC LN Equity (and optionally FTSE 100).
#    Include at least Aug 2024 – Feb 2025.
# 2️⃣ Save as Excel file named 'dcc_tender.xlsx' with the following columns:
#       Date          - Date (YYYY-MM-DD)
#       PX_LAST       - Closing price
#       VOLUME        - Daily trading volume
#       MarketCap     - Market cap in GBP
#       SharesOut     - Shares outstanding
#       FreeFloat     - Free float percentage
#       IndexWeight   - (optional) FTSE membership weight (%)
#       FTSE100       - (optional) FTSE 100 closing value
# 3️⃣ Run this notebook cell, upload the file when prompted, and the analysis will run.

# ================================================================
# 🧩 Import Libraries
# ================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from IPython.display import display
from ipywidgets import FileUpload
import io

# ================================================================
# 📁 Upload Bloomberg Excel File
# ================================================================
print("📂 Please upload your Bloomberg Excel file (e.g. dcc_tender.xlsx)")
uploader = FileUpload(accept='.xlsx', multiple=False)
display(uploader)

def load_uploaded_file(uploader):
    if len(uploader.value) == 0:
        raise ValueError("❌ No file uploaded. Please upload your .xlsx file.")
    upload = list(uploader.value.values())[0]
    df = pd.read_excel(io.BytesIO(upload['content']))
    print(f"✅ Loaded: {upload['metadata']['name']} — {df.shape[0]} rows")
    return df

# --- Wait for upload, then rerun this cell ---
if len(uploader.value) == 0:
    raise SystemExit("⏸️ Upload your Excel file above, then re-run this cell.")

# ================================================================
# 🧮 Load and Prepare Data
# ================================================================
df = load_uploaded_file(uploader)
df['Date'] = pd.to_datetime(df['Date'])
df = df.sort_values('Date')
df.set_index('Date', inplace=True)

# ================================================================
# ⚙️ Tender Offer Parameters
# ================================================================
tender_value = 600_000_000   # £600mn
tender_start = datetime(2024, 11, 1)
tender_end = datetime(2024, 12, 31)

# ================================================================
# 📈 Derived Metrics
# ================================================================
df['PriceChange_%'] = df['PX_LAST'].pct_change() * 100
df['MarketCapChange_%'] = df['MarketCap'].pct_change() * 100

# --- Estimate Shares Redeemed ---
avg_tender_price = df.loc[tender_start:tender_end, 'PX_LAST'].mean()
shares_redeemed = tender_value / avg_tender_price

df['Adj_SharesOut'] = df['SharesOut']
df.loc[df.index >= tender_end, 'Adj_SharesOut'] = (
    df.loc[df.index >= tender_end, 'SharesOut'] - shares_redeemed
)
df['Adj_MarketCap'] = df['PX_LAST'] * df['Adj_SharesOut']

# --- Recalculate Index Weight (if available) ---
if 'IndexWeight' in df.columns:
    df['Adj_IndexWeight'] = df['Adj_MarketCap'] / df['Adj_MarketCap'].sum() * 100
else:
    df['Adj_IndexWeight'] = np.nan

# --- FTSE100 Comparison (optional) ---
if 'FTSE100' in df.columns:
    df['FTSE_Return_%'] = df['FTSE100'].pct_change() * 100
    df['Rel_Perf_%'] = df['PriceChange_%'] - df['FTSE_Return_%']

# ================================================================
# 🧠 Summary Statistics
# ================================================================
summary = {
    "Avg Tender Price (£)": round(avg_tender_price, 2),
    "Est. Shares Repurchased (mn)": round(shares_redeemed / 1e6, 2),
    "Share Reduction (%)": round(shares_redeemed / df['SharesOut'].iloc[-1] * 100, 2),
    "Pre-Tender Market Cap (£bn)": round(df.loc[:tender_start, 'MarketCap'].iloc[-1] / 1e9, 2),
    "Post-Tender Market Cap (£bn)": round(df.loc[tender_end:, 'Adj_MarketCap'].iloc[0] / 1e9, 2),
}
display(pd.DataFrame(summary, index=["Summary"]))

# ================================================================
# 📊 Visualisations
# ================================================================
plt.figure(figsize=(10,5))
plt.plot(df.index, df['PX_LAST'], label="DCC Share Price")
plt.axvspan(tender_start, tender_end, color='orange', alpha=0.2, label="Tender Period")
plt.title("DCC Share Price vs Tender Offer Period")
plt.xlabel("Date"); plt.ylabel("Price (£)")
plt.legend(); plt.grid(True); plt.show()

plt.figure(figsize=(10,5))
plt.plot(df.index, df['MarketCap'] / 1e9, label="Reported Market Cap (£bn)", alpha=0.6)
plt.plot(df.index, df['Adj_MarketCap'] / 1e9, label="Adjusted Market Cap (£bn)", linewidth=2)
plt.axvspan(tender_start, tender_end, color='orange', alpha=0.2)
plt.title("Market Cap Impact (Adjusted for £600mn Tender)")
plt.xlabel("Date"); plt.ylabel("£ Billion")
plt.legend(); plt.grid(True); plt.show()

if 'FTSE100' in df.columns:
    plt.figure(figsize=(10,5))
    plt.plot(df.index, df['Rel_Perf_%'].cumsum(), label="Relative Perf. vs FTSE100")
    plt.axvspan(tender_start, tender_end, color='orange', alpha=0.2)
    plt.title("Cumulative Relative Performance vs FTSE 100")
    plt.xlabel("Date"); plt.ylabel("Cumulative %")
    plt.legend(); plt.grid(True); plt.show()

print("✅ Analysis complete.")



import bql
import pandas as pd

# ----------------------------------------
# Connect to BQL
# ----------------------------------------
bq = bql.Service()

# ----------------------------------------
# Bloomberg-like function wrappers (BQuant style)
# ----------------------------------------

# --- BDS: Bulk dataset (e.g., index members)
def bds(tkr, field):
    if field == "INDX_MEMBERS":
        req = bql.Request(tkr, {"members": bq.data.memberships()})
        df = bq.execute(req).as_df()
        return df
    else:
        raise NotImplementedError(f"BDS field {field} not yet implemented in this wrapper")

# --- BDP: Snapshot data
def bdp(tkrs, field):
    if isinstance(tkrs, str):
        tkrs = [tkrs]
    req = bql.Request(tkrs, {field: getattr(bq.data, field)()})
    df = bq.execute(req).as_df()
    return df.pivot(index="ticker", values=field)

# --- BDH: Historical time series
def bdh(tkrs, field, start, end):
    if isinstance(tkrs, str):
        tkrs = [tkrs]
    fld = getattr(bq.data, field)(dates=bq.func.range(start, end, "daily"))
    req = bql.Request(tkrs, {field: fld})
    df = bq.execute(req).as_df()
    return df.pivot(index="date", columns="ticker", values=field)

# ----------------------------------------
# Example usage
# ----------------------------------------

# 1. Get index members
basket = "SPX Index"   # replace with your custom basket
members = bds(basket, "INDX_MEMBERS")
print("Members:\n", members.head())

# 2. Get snapshot (e.g., last price)
px_last = bdp(["AAPL US Equity", "MSFT US Equity"], "px_last")
print("\nSnapshot prices:\n", px_last)

# 3. Get historical (e.g., daily closes)
hist = bdh(["AAPL US Equity", "MSFT US Equity"], "px_last", "2024-01-01", "2024-02-01")
print("\nHistorical prices:\n", hist.head())